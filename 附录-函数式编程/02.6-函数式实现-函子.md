# 02.6-函数式实现-函子

## 一 函子实现

### 1.1 函子的概念

> 函子：函子（Functor）是一个普通对象（或者说一个类），它实现了 map 函数，在遍历每个对象值的时候生成了一个新的对象

简单来说，函子就是一个持有值的容器，如下所示：

```js
class Container {
  constructor(value) {
    this.value = value
  }

  static of(value) {
    return new Container(value)
  }
}
```

从上看出，如果要让容器持有值，使用 new 创建实例，或者 of 静态方法即可。甚至来说传入的 value 也是 Container 的另外一个实例。

### 1.2 函子的 map 方法

简单实现 map 方法，用来处理 Container 中持有的数据：

```js
    map(fn) {
        return Container.of(fn(this.value))
    }
```

示例：将函子内的数据翻倍：

```js
const doubleNum = (num) => num * 2

let res = Container.of(3).map(doubleNum)

console.log(res) // Container {value: 6}
```

## 二 Maybe 函子

### 2.1 Maybe 函子概念

Maybe 既然是一个函子，就意味着他实现了 map，只不过在实现上有所不同：

```js
class MayBe extends Container {
  static of(value) {
    return new MayBe(value)
  }
  isNothing() {
    return this.value === null || this.value === undefined
  }
  map(fn) {
    return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value))
  }
}
```

我们可以看到 Maybe 函子的 map 与简单函子的 map 很像，只是先检查了容器中的值是否存在，所以 Maybe 函子可以为错误处理提供一个抽象：

```js
const upper = (x) => x.toUpperCase()

// 使用简单函子报错：null上不存在 toUpperCase
// let res = Container.of(null).map(upper)

// 使用Maybe函子后，不会报错
let res = MayBe.of(null).map(upper)
console.log(res) // MayBe {value: null}
```

这里如果我们采用链式调用，出现了 null 值也是没有问题的：

```js
const upper = (x) => x.toUpperCase()

let res = MayBe.of('hello ')
  .map(upper)
  .map(() => null)
  .map((x) => x + ' WORLD!')
console.log(res) // MayBe {value: null}
```

而且我们会发现，即使出现了 null 错误，所有的 map 函数都被调用了。

### 2.2 Maybe 函子示例
