# 01.2-编程思想-函数式与面向对象

## 一 面向对象编程与函数式编程区别

> 面向对象编程（ 00 ）通过封装变化使得代码更易理解 。
> 函数式编程（ FP ）通过最小化变化使得代码更易理解。

面向对象的应用大多是命令式的，所以在很大程度上依赖封装来保护自身和继承可变状态的完整性，只能通过实例方法来暴露、修改这些状态。这样做就会导致对象的数据与其具体行为以一种内聚的包裹形式紧紧耦合在一起。不过这正是面向对象程序的目的，即：对象是抽象的核心。

函数式编程不需要隐藏数据，通常使用一些更小的且简单的数据类型。由于一切都是不可变的，对象都是可以直接拿来使用的，而且是通过定义在对象作用域外的函数来实现的。即：数据与行为是松耦合的，函数是抽显得主要形式。

面向对象的程序设计通过特定的行为将很多数据类型逻辑地连接在一起，函数式编程则关注如何在这些数据类型之上通过组合来连接各种操作。 因此存在一个两种编程范式
都可以被有效利用的平衡点。 需要把对象视为不可变的实体或值，并将它们的功能拆分成可应用在该对象上的函数，如下的一个 Person 中的方法：

```js
class Person {
  get fullname() {
    return [this.firstname, this.lastname].join(' ')
  }
}

// 修改为：
let fullname = (person) => [person.firstname, person.lastname].join(' ')
```

上述示例可以避免使用 this 引用来访问对象的数据。因为 this 是有缺点的：this 给与超出方法作用域的实例层级的数据访问能力，导致了副作用。

下面的示例演示了使用面向对象方式找到同一地址的人、同一地址且同一学校的人的两个方法：

```js
class Person {
  constructor(firstname, lastname, id) {
    this.firstname = firstname
    this.lastname = lastname
    this.id = id
    this.address = null
  }

  // 找到同一地址的人
  findSameAddress(friends) {
    const result = []
    for (let idx in friends) {
      if (this.address === friends[idx].address) {
        result.push(friends[idx])
      }
    }
    return result
  }
}

class Student extends Person {
  constructor(firstname, lastname, id, school) {
    super(firstname, lastname, id)
    this.school = school
  }
  // 找到同一地址同一学校的人
  findSameAddressAndSchool(friends) {
    const closeFrineds = super.findSameAddress(friends)
    const result = []
    for (let idx in closeFrineds) {
      if (this.school === closeFrineds[idx].school) {
        result.push(closeFrineds[idx])
      }
    }
    return result
  }
}

const p1 = new Student('张', '三', 1, '育新小学')
p1.address = '中国'
const p2 = new Student('李', '四', 2, '育才小学')
p2.address = '中国'
const p3 = new Student('王', '五', 3, '育新小学')
p3.address = '中国'
const p4 = new Student('James', 'Jackson', 4, '育才小学')
p4.address = '美国'
const p5 = new Student('Gem', 'Green', 5, '佐治亚小学')
p5.address = '美国'

// 找到和 p1 一个地址的人
let r1 = p1.findSameAddress([p2, p3, p4, p5])
console.log(r1)

// 找到和p1 一个地址、一个学校的人
let r2 = p1.findSameAddressAndSchool([p2, p3, p4, p5])
console.log(r2)
```

现在改为函数式：

```js
const selector = (address, school) => {
  return (student) => {
    return student.address === address && student.school === school
  }
}

const findStudent = (friends, selector) => {
  return friends.filter(selector)
}

let res = findStudent([p1, p2, p3, p4, p5], selector('中国', '育新小学'))
console.log(res)
```

由上可见，面向对象的设计着重于数据与数据之间的关系，函数式则着重于操作如何执行，即行为。二者区别如下：

| 特性     | 函数式                   | 面向对象             |
| -------- | ------------------------ | -------------------- |
| 组合单元 | 函数                     | 对象                 |
| 编程风格 | 声明式                   | 命令式               |
| 数据行为 | 独立且怂耦合的纯函数     | 与方法紧耦合类       |
| 状态管理 | 将对象视为不可变的值     | 通过实例方法改变对象 |
| 流程控制 | 函数与递归               | 循环与条件           |
| 封装性   | 一切不可变，没有封装必要 | 需要保护数据的完整性 |
| 现成安全 | 可并发编程               | 实现困难             |

尽管它们之间存在差异，但有效构建应用程序的方法是混合两种范式。一方面，可以使用 与组成类型之间存在自然关系的富领域模型；另一方面，可以拥有一组能够应用于这些类型之上的纯函数。其中界限的确定取决于代码编写者是否对任一编程范式应用自如。由于 JavaScript 既是面向对象的，又是函数式的，因此在编写函数式代码时，需要特别注意控制状态的变化。
