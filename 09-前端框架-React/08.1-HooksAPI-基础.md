# 08.1-HooksAPI-基础

## 一 HooksAPI 简介

在早期版本中，函数式组件无法使用 state，只能作为无状态组件使用，这是因为函数式组件最大的问题是没有 this，即实例对象，这就造成了类组件中很多实例方法无法在函数式组件中得到使用。

Hook 是 React16.8 新增的重要特性，其核心功能是让函数式组件能够使用状态、生命周期等特性，自此 React 的组件不再存在无状态属性这个概念。Hook 的本质其实是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。

React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们会先介绍这些内置的 Hook。

增强后的函数式组件对比类组件：

- 代码可读性更强了：类组件的业务逻辑被分布在了不同的生命周期函数中，不利于维护，Hooks 可以将业务代码聚合
- 组件层级更浅：类组件需要使用 HOC/render props 等方式复用组件状态，增强功能，会增加组件的层级，Hooks 可以通过自定义 Hooks 实现。

贴士：Hook 是 100%向后兼容的，没有破坏性改动，反而是提供了更简明、直接的 API，如：props、state、context、refs、lifecircle。

Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：

- 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。
- 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）

贴士：目前暂时还没有对应不常用的 getSnapshotBeforeUpdate，getDerivedStateFromError 和 componentDidCatch 生命周期的 Hook 等价写法。

## 二 状态 Hooks：useState()

### 2.1 基本写法

函数式组件在 React16 之前无法使用状态，称为无状态组件，但是 HooksAPI 流行后，useState() 可以让函数式组件使用状态：

```js
import { useState } from 'react'

export default function Count(props) {
  // useState 返回是数组，数组的两个元素是：状态值、更新状态的方法
  let [count, setCount] = useState(0)

  function add() {
    // 函数式写法：
    // setCount(count => {
    //     return count + 1
    // })

    // 常规写法：是函数式写法的语法糖
    setCount(count + 1)
  }

  return (
    <div>
      状态值：{count}
      <button onClick={add}>点我修改状态</button>
    </div>
  )
}
```

### 2.2 多个状态使用

也支持多个状态一起使用：

```js
import { useState } from 'react'
export default function Count(props) {
  let [count, setCount] = useState(0)
  let [name, setName] = useState('Jack')

  function changeCount() {
    setCount(count + 1)
  }

  function changeName() {
    setName('Ross')
  }

  return (
    <div>
      count值：{count}
      <button onClick={changeCount}>点我修改 count</button>
      <hr />
      name 值：{name}
      <button onClick={changeName}>点我修改 name</button>
    </div>
  )
}
```

useState 与 class 里面的 this.state 提供的功能完全相同，调用 useState 后，随着函数退出，也依然会让 React 进行保存。

### 2.3 状态的异步更新

react 的状态是异步更新的：

```js
state = { count: 0 }

// count 增加的触发函数
add = () => {
  const { count } = this.state
  this.setState({ count: count + 1 })
  console.log('count: ', this.state.count) // 仍然输出 0
}
```

正确的写法是 setState 支持第二个参数，是一个 callback，代表状态改变之后执行的函数：

```js
state = { count: 0 }

// count 增加的触发函数
add = () => {
  const { count } = this.state
  this.setState({ count: count + 1 }, () => {
    console.log('count: ', this.state.count) // 仍然输出 0
  })
}
```

callback 是在状态更新、render() 执行之后才执行！

## 三 生命周期 Hooks：useEffect()

### 3.1 useEffect() 监控状态

函数组件没有生命周期函数， useEffect Hook 跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，实际上 useEffect 类似于他们的组合。

数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。

Effect Hook 可以让你在函数组件中执行副作用操作，示例将会在初次加载、任意状态改变时执行：

```js
let [count, setCount] = React.useState('Jack')
let [name, setName] = React.useState('Jack')

React.useEffect(() => {
  console.log('useEffect...')
}, [count, name])
```

第二个数组参数是可选的，意思是：监控该函数式组件内哪些状态。

- 空数组，则不会监控，只会在组件初次加载时执行 useEffect()。
- 数组参数不写，则监控所有状态。

useEffect() 可以在函数式组件中执行副作用操作，即监控组件状态的变更，模拟生命周期，比如在 React 中方发送 ajax，手动更改真实 DOM、启动定时器等，如下所示：

```js
useEffect(async () => {
  let data = await fetchUsers()
}, [])
```

贴士：与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。

### 3.2 多个 effect 实现关注点分离

使用 Hook 其中一个目的就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。下述代码是将前述示例中的计数器和好友在线状态指示器逻辑组合在一起的组件：

```js
class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
 handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }
  // ...
```

可以发现设置 document.title 的逻辑是如何被分割到 componentDidMount 和 componentDidUpdate 中的，订阅逻辑又是如何被分割到 componentDidMount 和 componentWillUnmount 中的。而且 componentDidMount 中同时包含了两个不同功能的代码。

类似可以使用多个 state 的 Hook 一样，可以将不相关逻辑分离到不同的 effect 中：

```js
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0)
  useEffect(() => {
    document.title = `You clicked ${count} times`
  })

  const [isOnline, setIsOnline] = useState(null)
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline)
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
    }
  })
  // ...
}
```

### 3.3 需要清除的 effect

useEffect 的第一个函数参数内部也可以返回一个函数，这个返回的函数会在组件卸载时触发，推荐在 return 中书写清理定时器等方法：

```js
React.useEffect(() => {
  console.log('mount...')
  return () => {
    console.log('component will unmount...')
  }
})
```

如下示例，每次状态改变，都会给 document 添加一个事件处理函数，所以需要做清除处理：

```js
const [pos, setPos] = useState({ x: 0, y: 0 })

useEffect(() => {
    const update = e => {
        setPosition({ x: e.clientX, y: e.clientY })
    }
    document.addEventListener('click', update)
    return () => {
        document.removeEventListener('click', update)
    }
})

return ()   // JSX
```

### 3.4 每次更新的时候都要运行 Effect

effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。

下面的示例是：一个用于显示好友是否在线的 FriendStatus 组件。从 class 中 props 读取 friend.id，然后在组件挂载后订阅好友的状态，并在卸载组件的时候取消订阅：

```js
componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
```

但是当组件已经显示在屏幕上时，friend prop 发生变化时会发生什么？ 我们的组件将继续展示原来的好友状态。这是一个 bug。而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。

在 class 组件中，我们需要添加 componentDidUpdate 来解决这个问题：

```js
componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // 取消订阅之前的 friend.id
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // 订阅新的 friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
```

忘记正确地处理 componentDidUpdate 是 React 应用中常见的 bug 来源。

现在看一下使用 Hook 的版本：

```js
function FriendStatus(props) {
  // ...
  useEffect(() => {
    // ...
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
```

它并不会受到此 bug 影响。(虽然我们没有对它做任何改动。)

并不需要特定的代码来处理更新逻辑，因为 useEffect 默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理。为了说明这一点，下面按时间列出一个可能会产生的订阅和取消订阅操作调用序列：

```js
// Mount with { friend: { id: 100 } } props
ChatAPI.subscribeToFriendStatus(100, handleStatusChange) // 运行第一个 effect

// Update with { friend: { id: 200 } } props
ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange) // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(200, handleStatusChange) // 运行下一个 effect

// Update with { friend: { id: 300 } } props
ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange) // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(300, handleStatusChange) // 运行下一个 effect

// Unmount
ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange) // 清除最后一个 effect
```

### 3.5 通过跳过 Effect 进行性能优化

在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决：

```js
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
```

这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：

```js
useEffect(() => {
  document.title = `You clicked ${count} times`
}, [count]) // 仅在 count 更改时更新
```

上面这个示例中，我们传入 `[count]` 作为第二个参数。这个参数是什么作用呢？如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 `[5]` 和后一次渲染的 `[5]` 进行比较。因为数组中的所有元素都是相等的(5 === 5)，React 会跳过这个 effect，这就实现了性能的优化。

当渲染时，如果 count 的值更新成了 6，React 将会把前一次渲染时的数组 `[5]` 和这次渲染的数组 `[6]` 中的元素进行对比。这次因为 5 !== 6，React 就会再次调用 effect。如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。

对于有清除操作的 effect 同样适用：

```js
useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline)
  }

  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
  }
}, [props.friend.id]) // 仅在 props.friend.id 发生变化时，重新订阅
```

如果要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。参阅文档，了解更多关于如何处理函数以及数组频繁变化时的措施内容。

如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。

如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 [] 作为第二个参数更接近大家更熟悉的 componentDidMount 和 componentWillUnmount 思维模式，但我们有更好的方式来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得额外操作很方便。

推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。
