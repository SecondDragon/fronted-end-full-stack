# 03.4-组件化开发-refs 获取原生 DOM

## 一 refs 概念

MVVM 框架推崇以数据来驱动界面更新，而不是直接操作 DOM，但是 React 官方还是提供了 refs 属性，用来直接操作 DOM。

在原生 JS 中，使用 id、class 等属性标识元素，即可操作该 DOM，在 React 中可以使用 `ref` 来标识 JSX 中的元素，组件会将标识了 ref 的元素收集到自身的 refs 属性中，开发者便可以操作对应 DOM 了，而且这里获取到的是真实 DOM！

不过官方仍然不推荐不推荐大量使用 ref，这会导致当前页面绑定的耦合度过高，不利于后期扩展，维护。

## 二 refs 使用

### 2.1 使用方式一：字符串

在组件、DOM 节点上使用字符串直接标识元素，但是该方式已经不被 React 官方推荐：

```js
class Comp extends React.Component {
  showRefs = () => {
    console.log(this.refs)
    console.log(this.refs.input1.value)
  }
  render() {
    return (
      <div>
        <input ref="input1" type="text" />
        <input ref="input2" type="password" />
        <button onClick={this.showRefs}>点击获取 refs</button>
      </div>
    )
  }
}
```

过度使用 refs 属性会造成组件结构的臃肿、混乱，存在效率问题，依据层级关系合理使用 state 属性才是更恰当的。

### 2.2 使用方式二：回调函数

回调函数方式可以替换字符串方式：

```js
class Comp extends React.Component {
  cb = (c) => {
    console.log('被调用，c:', c) // c 为 input
    this.input1 = c
  }
  showRefs = () => {
    const { input1 } = this
    console.log(input1.value)
  }
  render() {
    return (
      <div>
        {/*<input ref={c=>this.input1 = c;console.log('被调用，c:',c)} type="text" />*/}
        <input ref={this.cb} type="text" />
        <button onClick={this.showRefs}>点击获取 refs</button>
      </div>
    )
  }
}
```

上述的回调函数在页面被加载时，就会被调用一次，即输出：`被调用，c:`。

注意：如果 ref 是以内联函数形式存在，在以后组件**再更新**时会执行两次，第一次传入的是 null，第二次传入的是元素对象。因为每次渲染时会创建一个新的函数实例，所以 React 会清空旧的 ref 并且设置新的，上述直接书写的方式可以解决该问题。

### 2.3 使用方式三：React.createRef()

React16.3 提供了新的 refs 使用方式，即 React.createRef()：

```js
class Comp extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.myRef} />
        <button
          onClick={() => {
            console.log(this.myRef.current.value)
          }}
        >
          点击获取当前 input 数据
        </button>
      </div>
    )
  }
}
```

## 三 Refs 转发

### 3.1 Refs 转发示例

Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。

Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。

```js
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref}>{props.children}</button>
))

// 你可以直接获取 DOM button 的 ref：
function Demo() {
  const ref = React.createRef()
  return <FancyButton ref={ref}>Click me!</FancyButton>
}
```

这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。

以下是对上述示例发生情况的逐步解释：

- 通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。
- 通过指定 ref 为 JSX 属性，将其向下传递给 `<FancyButton ref={ref}>`。
- React 传递 ref 给 forwardRef 内函数 (props, ref) => ...，作为其第二个参数。
- 向下转发该 ref 参数到 `<button ref={ref}>`，将其指定为 JSX 属性。
- 当 ref 挂载完成，ref.current 将指向 `<button>` DOM 节点。

注意：第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。

### 3.2 组件库维护者的注意事项

当你开始在组件库中使用 forwardRef 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。 这是因为你的库可能会有明显不同的行为（例如 refs 被分配给了谁，以及导出了什么类型），并且这样可能会导致依赖旧行为的应用和其他库崩溃。

出于同样的原因，当 React.forwardRef 存在时有条件地使用它也是不推荐的：它改变了你的库的行为，并在升级 React 自身时破坏用户的应用。

### 3.3 在高阶组件中转发 refs

在高阶组件中转发 refs 特别有用：

```js
function logProps(WrappedComponent) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps)
      console.log('new props:', this.props)
    }

    render() {
      return <WrappedComponent {...this.props} />
    }
  }

  return LogProps
}
```

“logProps” HOC 透传（pass through）所有 props 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props：

```js
class FancyButton extends React.Component {
  focus() {
    // ...
  }

  // ...
}

// 我们导出 LogProps，而不是 FancyButton。
// 虽然它也会渲染一个 FancyButton。
export default logProps(FancyButton)
```

下面的示例有一点需要注意：refs 将不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。

这意味着用于我们 FancyButton 组件的 refs 实际上将被挂载到 LogProps 组件：

```js
import FancyButton from './FancyButton'

const ref = React.createRef()

// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。
// 尽管渲染结果将是一样的，
// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！
// 这意味着我们不能调用例如 ref.current.focus() 这样的方法
;<FancyButton label="Click Me" handleClick={handleClick} ref={ref} />
```

幸运的是，我们可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。例如：

```js
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps)
      console.log('new props:', this.props)
    }

    render() {
      const { forwardedRef, ...rest } = this.props

      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return <Component ref={forwardedRef} {...rest} />
    }
  }

  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />
  })
}
```

### 3.4 在 DevTools 中显示自定义名称

React.forwardRef 接受一个渲染函数。React DevTools 使用该函数来决定为 ref 转发组件显示的内容。

例如，以下组件将在 DevTools 中显示为 “ForwardRef”：

```js
const WrappedComponent = React.forwardRef((props, ref) => {
  return <LogProps {...props} forwardedRef={ref} />
})
```

如果你命名了渲染函数，DevTools 也将包含其名称（例如 “ForwardRef(myFunction)”）：

```js
const WrappedComponent = React.forwardRef(function myFunction(props, ref) {
  return <LogProps {...props} forwardedRef={ref} />
})
```

你甚至可以设置函数的 displayName 属性来包含被包裹组件的名称：

```js
function logProps(Component) {
  class LogProps extends React.Component {
    // ...
  }

  function forwardRef(props, ref) {
    return <LogProps {...props} forwardedRef={ref} />
  }

  // 在 DevTools 中为该组件提供一个更有用的显示名。
  // 例如 “ForwardRef(logProps(MyComponent))”
  const name = Component.displayName || Component.name
  forwardRef.displayName = `logProps(${name})`

  return React.forwardRef(forwardRef)
}
```
