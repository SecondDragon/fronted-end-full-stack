# 04.1-常见操作-事件处理

## 一 基本事件操作

### 1.1 绑定事件

React 推荐使用行内直接绑定的方式，其事件命采用小驼峰式（camelCase）：

```js
function Demo() {
  const handleClick = (e) => {
    console.log('click--', e.target)
  }

  return <div onClick={handleClick}>demo</div>
}
```

在类组件中，通常的做法是将事件处理函数声明为 class 中的方法：

```js
class Demo extends React.Component {
  handleClick(e) {
    console.log('click--', e.target)
  }
  render() {
    return <div onClick={this.handleClick}>demo</div>
  }
}
```

如果和原生绑定事件一致，行内也采用类似这样的写法： `onClick={handleClick()}`，那么就会出现 handleClick 被调用两次的现象，且绑定的事件变成 handleClick 的返回值，所以一般不这样做。

贴士：React 通过`onXX` 方式指定事件处理函数，React 事件与原生事件不完全相同，是 React 通过事件委托方式处理的（委托给最外层元素）。e 也是一个合成事件，不需要考虑兼容性，通过 `event.target` 可以得到事件的原生 DOM 元素。

### 1.2 阻止默认行为

React 中阻止 DOM 默认行为需要通过事件对象提供的方法实现：

```js
function Form() {
  function handleSubmit(e) {
    e.preventDefault()
    console.log('You clicked submit.')
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  )
}
```

## 二 类组件事件的 this 指向问题

### 2.1 事件函数中的 this 为 undefined

如下所示：handleClick() 中的 this 是 undefined。

```js
class Demo extends React.Component {
  state = {
    num: 0,
  }
  handleClick() {
    let { num } = this.state
    num += 1
    this.setState({ num: num })
  }
  render() {
    return <div onClick={this.handleClick}>{this.state.num}</div>
  }
}
```

如果我们在构造器、render() 内部的打印 this，发现 this 都是 Demo 对象的实例，但是在事件方法中打印 this 却是 undefined，这是因为，这些方法不是用实例调用的，调用者是 window。

在类 Title 中，构造器、render() 内部的 this 都是实例对象本身，但是在 test() 中却是 undefined 的！！这是因为前者都是通过实例调用的，而 test() 的调用者是 window！

其类似原理如下示例：

```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  info() {
    console.log(this)
  }
}

const p = new Person('Jack', 18)
p.info() // 正确输出 this 实例

const o = p.info
o() // undefined
```

`info()` 方法是放置在 Person 的原型上的，Person 实例并没有 `info()`方法，使用实例调用`p.info()`是顺着原型链找到了原型上的方法进行调用的。而 `const o = p.info` 赋值语句中，`p.info`并没有调用 `info()`方法，而是简单赋值，故而是 undefined。

同理，组件中自定义方法默认并不是由组件实例调用，而是作为事件的回调在使用！！这就造成了自定义方法的 this 可能是全局的 window，但是组件中的方法也默认开启了局部的严格模式，所以下列示例函数`fn()`中的 this 默认是 undefined。

### 2.2 解决方案一：箭头函数

由于箭头函数中的 this 是其定义的地方，所以可以修改事件函数为箭头函数方式：

```js
handleClick = () => {
  let { num } = this.state
  num += 1
  this.setState({ num: num })
}
```

### 2.3 解决方案二：bind

bind 可以绑定函数调用对象，所以事件方法调用时可以指定调用者：

```js
render() {
    return <div onClick={this.handleClick.bind(this)}>{ this.state.num}</div>
}
```

也可以在构造器中直接绑定：

```js
constructor(props) {
  super(props)
  this.handleClick = this.handleClick.bind(this)
}
```

## 三 向事件处理程序传递参数

在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：

```js
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。

在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。
