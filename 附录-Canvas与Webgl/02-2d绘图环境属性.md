# 02-2d 绘图环境属性

## 一 常见图形绘制

### 1.0 API 网址

2d 绘图环境的具体属性的用法，可以查看网止：[https://developer.mozilla.org/zh-cn/docs/Web/API/CanvasRenderingContext2D]

### 1.1 绘制矩形

矩形的填充、描边、清除：

-   填充：`fillRect(double x, double y, double w, double h)`，对应颜色 `ctx.fillStyle = 'green'`
-   描边：`strokeRect(double x, double y, double w, double h)`，对应颜色 `ctx.strokStyle = 'green'`
-   清除：`clearRect(double x, double y, double w, double h)`

### 1.2 绘制路径

绘制路径可以实现一个不规则的多边形，不过要注意路径都是闭合的：

```js
// 创建一个路径
ctx.beginPath()
// 描述绘制点
ctx.moveTo(100, 100)
// 描述行进的路径
ctx.lineTo(200, 200)
ctx.lineTo(400, 180)
ctx.lineTo(380, 50)
// 闭合路径
ctx.closePath()
// 绘制该图形
ctx.strokeStyle = 'red'
ctx.stroke() // 绘制不规则图形
// 填充该图形
ctx.fillStyle = 'green'
ctx.fill()
```

### 1.3 绘制圆弧

```js
// 创建一个路径
ctx.beginPath()
// 描述绘制点：200,200 为起始坐标，100为半径，0,1 为弧度，默认值false 为顺时针
ctx.arc(200, 200, 0, 1, 100, false) // 0,1 改为  0 2*Math.PI 则为1个圆
// 绘制该图形
ctx.strokeStyle = 'red'
ctx.stroke() // 绘制不规则图形
```

## 二 canvas 的开发实践

在实际开发环境中，canvas 绘制的图形较为复杂，可以使用面向对象的方式开发，比如绘制一个球：

```js
class Ball {
    constructor(ctx, color) {
        this.ctx = ctx
        this.posX = parseInt(Math.random() * ctx.canvas.width)
        this.posY = parseInt(Math.random() * ctx.canvas.height)
        this.posR = 10
        this.moveX = parseInt(Math.random() * 10) - 5
        this.moveY = parseInt(Math.random() * 10) - 5
        this.color = color || 'grey'
    }
    // 模拟边际碰撞效果
    update() {
        this.posX += this.moveX
        this.posY += this.moveY
        if (this.posX < this.posR || this.posX > this.ctx.canvas.width) {
            this.moveX = -this.moveX
        }
        if (this.posY < this.posR || this.posY > this.ctx.canvas.height) {
            this.moveY = -this.moveY
        }
    }
    render() {
        console.log('zhi11:', this)
        this.ctx.beginPath()
        this.ctx.globalAlpha = 1
        this.ctx.arc(this.posX, this.posY, this.posR, 0, 2 * Math.PI, false)
        this.ctx.fillStyle = this.color
        this.ctx.fill()
    }
}

// 业务代码
let ctx = document.querySelector('#mycanvas').getContext('2d')
let balls = []

ctx.canvas.addEventListener('mouseover', e => {
    for (let i = 0; i < 10; i++) {
        balls.push(new Ball(ctx, 'green'))
    }
})

ctx.canvas.addEventListener('mouseout', e => {
    balls = []
})

setInterval(() => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
    balls.map(item => {
        item.update()
        item.render()
    })
}, 30)
```

## 三 Canvas 状态保存与恢复

Canvas 的 API 提供了两个名叫 save() 和 restore() 的方法，用于保存及恢复当前 canvas 绘图环境的所有属性。

绘制环境状态的保存与恢复，可以让开发者很方便的做出临时性的状态改动。

**save() 和 restore()可以嵌套式调用：**

绘图环境的 save()方法会将当前的绘图环境压入堆栈顶部。对应的 restore()方法则会从堆栈顶部弹出一组状态信息，并据此恢复当前环境的各个状态。

```js
function drawGrid(strokeStyle, fillStyle) {
    // save a context on a stack
    controlContext.save()

    controlContext.fillStyle = fillStyle
    controlContext.strokeStyle = strokeStyle

    // restore the context from the stack
    controlContext.restore()
}
```

**注意：**canvas 状态并不包括当前路径或位图。只能通过调用 beginPath()来重置路径。至于位图，它是 canvas 的一个属性，并不属于绘图环境对象，但是可以通过绘图环境对象来访问它（在环境对象上调用 getImageData()）。
