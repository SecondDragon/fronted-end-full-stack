# 07.2-HTML5-WebAPI 变化

## 一 跨文档通信

跨文档消息，有时候也简称为 XDM（ cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力。例如， www.wrox.com 上的页面想要与包含在内嵌窗格中的 p2p.wrox.com 上面的页面通信。

在过去，跨文档通信（跨源、跨窗口，cross-document messaging）往往是与服务端进行数据交互来实现的，并且需要借助轮询或者 Connect 技术来监听消息。

XDM 主要用于实现安全的跨源通信，可以用在窗口之间通信、工作线程之间通信。H5 提供了 PostMessages() 方法即可把数据传递到另一个位置

```js
// 参数一：消息体
// 参数二：消息来自哪个域
// 参数三：可选。是一串和 message 同时传递的 Transferable 对象，这些对象的所有权将被转译给消息的接收方，而发送乙方将不再保有所有权

let iframeWindow = document.getElementById('myframe').contentWindow // 获取iframe
iframeWindow.postMessage('A secret', 'http://www.demo.com')
```

iframe 发送示例：

```html
<button id="btn">点击发送消息给 iframe</button>
<iframe src="http:127.0.0.1/iframe.html"></iframe>
<script>
  let btn = document.querySelector('#btn')
  let data = ['周一', '周二', '周五']
  btn.onclick = function () {
    alert('执行发送数据给 iframe？')
    window.parent.postMessage(data, 'http:127.0.0.1/iframe.html')
  }
</script>
```

iframe 接收数据示例：

```js
// 接收到XDM消息后，window上异步触发 message事件
window.addEventListener('message', (event) => {
  // 确保来自预期发送者
  if (event.origin == 'http://www.wrox.com') {
    // 对数据进行一些处理
    processMessage(event.data)
    // 可选：向来源窗口发送一条消息
    event.source.postMessage('Received!', 'http://p2p.wrox.com')
  }
})
```

传给 onmessage 事件处理程序的 event 对象包含以下 3 方面重要信息。

- data：作为第一个参数传递给 postMessage()的字符串数据。
- origin：发送消息的文档源，例如"http://www.wrox.com"。
- source：发送消息的文档中 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中执行 postMessage()方法。如果发送窗口有相同的源，那么这个对象应该就是 window 对象。

大多数情况下， event.source 是某个 window 对象的代理，而非实际的 window 对象。因此不能通过它访问所有窗口下的信息。最好只使用 postMessage()，这个方法永远存在而且可以调用。

XDM 有一些怪异之处。首先， postMessage()的第一个参数的最初实现始终是一个字符串。后来，第一个参数改为允许任何结构的数据传入，不过并非所有浏览器都实现了这个改变。为此，最好就是只通过 postMessage() 发送字符串，如果需要传递结构化数据，那么最好先对该数据调用 JSON.stringify()，通过 postMessage()传过去之后，再在 onmessage 事件处理程序中调用 JSON.parse()。

## 二 通知

Notifications API 用于向用户显示通知，比传统的 alert() 更灵活，常用于 Service Worker，使得网页看起来像一个应用。

Notifications API 有被滥用的可能，因此默认会开启两项安全措施：

- 通知只能在运行在安全上下文的代码中被触发；
- 通知必须按照每个源的原则明确得到用户允许。

```js
Notification.requestPermission().then((permission) => {
  console.log('User responded to permission request:', permission)
})
```

Notification 构造函数用于创建和显示通知，第二个可选参数可以对通知进行自定义：

```js
const n = new Notification('Title text!', {
  body: 'Body text!',
  image: 'path/to/image.png',
  vibrate: true,
})

// 关闭通知
setTimeout(() => n.close(), 1000)
```

Notifications API 提供了 4 个用于添加回调的生命周期方法：

```txt
onshow 在通知显示时触发；
onclick 在通知被点击时触发；
onclose 在通知消失或通过 close() 关闭时触发；
onerror 在发生错误阻止通知显示时触发。
```

```js
const n = new Notification('foo')
n.onshow = () => console.log('Notification was shown!')
n.onclick = () => console.log('Notification was clicked!')
n.onclose = () => console.log('Notification was closed!')
n.onerror = () => console.log('Notification experienced an error!')
```

## 三 H5 原生拖放

在 H5 规范中，拖动元素，将依次触发：`dragstart`，`drag`，`dragend`三个事件。

当某个元素被拖动到一个有效的放置目标上时，将依次触发：`dragenter`，`dragover`，`dragleave/drop`三个事件。如果拖拽元素离开了目标元素位置，则触发 dragleav 事件，如果放置到了目标元素位置，则触发 drop 事件。

如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生 drop 事件。不过，任何元素都可以被设置为放置目标元素。

设置元素可以放置方式是重写 dragenter、dragover 事件的默认行为：

```js
let droptarget = document.getElementById('droptarget')
EventUtil.addHandler(droptarget, 'dragover', function (event) {
  EventUtil.preventDefault(event)
})

EventUtil.addHandler(droptarget, 'dragenter', function (event) {
  EventUtil.preventDefault(event)
})
```

在 Firefox 中，若拖拽图像，则页面会转向图像文件，若拖拽文本，则会导致无效 URL 错误，所以这里需要取消 Firefox 的 drop 事件的默认行为，阻止其打开 URL：

```js
EventUtil.addHandler(droptarget, 'drop', function (event) {
  EventUtil.preventDefault(event)
})
```

dataTransfer 对象是拖拽事件对象的属性，用于存储数据：

```js
//设置和接收文本数据
event.dataTransfer.setData('text', 'some text')
let text = event.dataTransfer.getData('text')
//设置和接收 URL
event.dataTransfer.setData('URL', 'http://www.wrox.com/')
let url = event.dataTransfer.getData('URL')
```

默认情况下，图像、链接和文本是可以拖动的，也就是说，不用额外编写代码，用户就可以拖动它们。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。

HTML5 为所有 HTML 元素规定了一个 draggable 属性，表示元素是否可以拖动。图像和链接的 draggable 属性自动被设置成了 true，而其他元素这个属性的默认值都是 false。

## 四 多媒体控制

HTML5 新增了两个与媒体相关的元素：`<audio>`和`<video>`，可以取代 flash，为浏览器提供了嵌入音频和视频的统一解决方案。

嵌入方案：

```html
<!-- 嵌入视频 -->
<video id="myVideo">
  <source src="conference.webm" type="video/webm; codecs='vp8, vorbis'" />
  <source src="conference.ogv" type="video/ogg; codecs='theora, vorbis'" />
  <source src="conference.mpg" />
  Video player not available.
</video>

<!-- 嵌入音频 -->
<audio id="myAudio">
  <source src="song.ogg" type="audio/ogg" />
  <source src="song.mp3" type="audio/mpeg" />
  Audio player not available.
</audio>
```

### 2.5 计时 API

Date.now() 的时间精度很低，只有毫秒级。H5 额外规范了计时相关的 API：window.performance.now()，该方法返回一个微妙精度的浮点数，可以保证时间冲的单调增长：

```js
const t0 = performance.now();
const t1 = performance.now();
console.log(t0); // 1768.625000026077
console.log(t1); // 1768.6300000059418
const duration = t1 – t0;
console.log(duration); // 0.004999979864805937
```

performance.now() 计时器采用相对度量。这个计时器在执行上下文创建时从 0 开始计时。例如，打开页面或创建工作线程时，performance.now() 就会从 0 开始计时。由于这个计时器在不同上下文中初始化时可能存在时间差，因此不同上下文之间如果没有共享参照点则不可能直接比较 performance.now()。performance.timeOrigin 属性返回计时器初始化时全局系统时钟的值。

```js
const relativeTimestamp = performance.now()
const absoluteTimestamp = performance.timeOrigin + relativeTimestamp
console.log(relativeTimestamp) // 244.43500000052154
console.log(absoluteTimestamp) // 1561926208892.4001
```

Performance Timeline API 使用一套用于度量客户端延迟的工具扩展了 Performance 接口。性能度量将会采用计算结束与开始时间差的形式。这些开始和结束时间会被记录为 DOMHighResTimeStamp 值，而封装这个时间戳的对象是 PerformanceEntry 的实例。

浏览器会自动记录各种 PerformanceEntry 对象，而使用 performance.mark() 也可以记录自定义的 PerformanceEntry 对象。在一个执行上下文中被记录的所有性能条目可以通过 performance.getEntries() 获取：

```js
console.log(performance.getEntries())
// [PerformanceNavigationTiming, PerformanceResourceTiming, ... ]
```

这个返回的集合代表浏览器的性能时间线（performance timeline）。每个 PerformanceEntry 对象都有 name、entryType、startTime 和 duration 属性。

不过，PerformanceEntry 实际上是一个抽象基类，比如录自定义性能条目要使用 performance.mark() 方法：

```js
performance.mark('foo')
console.log(performance.getEntriesByType('mark')[0])
// PerformanceMark {
// name: "foo",
// entryType: "mark",
// startTime: 269.8800000362098,
// duration: 0
// }
```

在计算开始前和结束后各创建一个自定义性能条目可以计算时间差。最新的标记（mark）会被推到 getEntriesByType() 返回数组的开始：

```js
performance.mark('foo')
for (let i = 0; i < 1e6; ++i) {}
performance.mark('bar')
const [endMark, startMark] = performance.getEntriesByType('mark')
console.log(startMark.startTime - endMark.startTime) // 1.3299999991431832
```

除了自定义性能条目，还可以生成 PerformanceMeasure（性能度量）条目，对应由名字作为标识的两个标记之间的持续时间。PerformanceMeasure 的实例由 performance.measure() 方法生成：

```js
performance.mark('foo')
for (let i = 0; i < 1e6; ++i) {}
performance.mark('bar')
performance.measure('baz', 'foo', 'bar')
const [differenceMark] = performance.getEntriesByType('measure')
console.log(differenceMark)
```

Navigation Timing API 提供了高精度时间戳，用于度量当前页面加载速度。浏览器会在导航事件发生时自动记录 PerformanceNavigationTiming 条目。这个对象会捕获大量时间戳，用于描述页面是何时以及如何加载的：

```js
// 算了 loadEventStart 和 loadEventEnd 时间戳之间的差
const [performanceNavigationTimingEntry] = performance.getEntriesByType('navigation');
console.log(performanceNavigationTimingEntry)

console.log(performanceNavigationTimingEntry.loadEventEnd –
performanceNavigationTimingEntry.loadEventStart);
// 0.805000017862767
```

Resource Timing API 提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。浏览器会在加载资源时自动记录 PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度：

```js
// 计算加载一个特定资源所花的时间
const pre = performance.getEntriesByType('resource')[0]
console.log(pre)

console.log(pre.responseEnd – pre.requestStart)
// 493.9600000507198
```
