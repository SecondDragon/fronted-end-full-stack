# 05.2-DOM-Element 节点操作

## 一 Element 类型的常见操作

### 1.1 节点选择

Element 类型就是 Web 开发中最常用的类型，对其的操作涉及大量的 API。

获取节点的方式有：

```js
// 通用的 元素节点选择 API
document.getElementById('demo') //通过 id 找到 HTML 元素
document.getElementsByTagName('div')[0] //通过标签名找到 HTML 元素获得的是标签伪数组
document.getElementsByClassName('a') //通过类名找到 HTML 元素，在部分 IE 中无效

// HTML5 中新增的节点选择 API
document.querySelector() // 可以传入 CSS 选择符，返回与该模式匹配的第一个元素
document.querySelectorAll() // 可以传入 CSS 选择符，返回的是一个 NodeList 的实例

// 该方法浏览器支持率较低
document.matchesSelector() // 可以传入 CSS 选择符，返回是否匹配的布尔
```

document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。

- document.anchors 包含文档中所有带 name 属性的<a>元素。
- document.applets 包含文档中所有<applet>元素（因为<applet>元素已经不建议使用，所
  以这个集合已经废弃）。
- document.forms 包含文档中所有<form>元素（与 document.getElementsByTagName ("form")
  返回的结果相同）。
- document.images 包含文档中所有<img>元素（与 document.getElementsByTagName ("img")
  返回的结果相同）。
- document.links 包含文档中所有带 href 属性的<a>元素。

这些特殊集合始终存在于 HTMLDocument 对象上，而且与所有 HTMLCollection 对象一样，其内容也会实时更新以符合当前文档的内容

### 1.2 节点层次关系成员

节点由于嵌套存在的原因，存在父子关系：

```js
// 获取父节点：一个节点只有一个父节点
element.parentNode

// 获取子元素节点
// 下列 API 不支持 IE8，IE8 使用 firstChid，firstChild 在标准中获取的是第一个子节点，同理 lastChid
fatherElement.firstElementChild //获取第一个子元素节点
fatherElement.lastElementChild //获取最后一个子元素节点

// 获取前后同级元素节点
// 下列 API 不支持 IE8，IE8 使用 previousSibling，previousSibling 在标准中获取的是前一个节点，同理 nextSibling
element.previousElementSibling //获取前一个节点
element.nextElementSibling //获取下一个节点

// 获取所有子元素节点
fatherElement.children // 非标准属性，但是得到了所有支持（在 IE8 中包含注释节点）

// 获取所有子节点
fatherElement.childNodes //标准属性，用来获取所有子节点数组，包括：文本、换行
```

### 1.3 节点的增、删、改、复制

```js
// 创建节点
document.write("节点与内容");     // 会抹掉整个页面已加载的元素，基本不使用，一般使用 innerHTML() 方法，这样不会造成整个额页面的重绘
document.writeln("节点与内容"); // 会加入换行符
document.createElement("节点与内容");

// 插入节点
fatherElement.appendChild(新节点);         // 父节点的最后插入一个新节点
fatherElement.insertBefore(新节点,参考节点); // 在参考节点前插入

// 删除节点
fatherElement.removeChild（子节点);      // 必须指定要删除的子节点

// 修改节点内容
element.innerHTML = "HTML 内容";  // 内容修改为新的 HTML 文档
element.innerText = "文本内容";    // 内容修改为纯文本

// 复制节点
newElement=element.cloneNode(参数); //参数可选复制节点
```

### 1.4 获取、修改元素节点的属性

修改元素节点属性的示例：

```js
imgElement.src = 'images/new.jpg' // 修改图片元素的路径
inputElement.value = '123' // 修改表单数据
inputElement.disabled = true // 禁用表单可点击
```

上述示例中通过点语法即可获得元素的属性，还可以通过下列方式：

```js
element.getAttribute('id') // 获取 id 属性值
element.getAttribute('backgroundColor') // 获取背景色
```

点语法只能获得元素自身的固有属性，`getAttribute()` 还能获得自定义属性：

```html
<div index="a" id="box">111</div>
<script>
  let box = document.querySelector('#box')
  console.log(box.getAttribute('index')) // a
  box.setAttribute('index', 'b')
  console.log(box.getAttribute('index')) // b
</script>
```

但是上述写法是不规范的，在 H5 中，约定自定义属性用 data- 开头，而且可以直接通过 dataset 属性获取：

```html
<div data-index="a" id="box">111</div>
<script>
  let box = document.querySelector('#box')
  // dataset 只能获取 data- 开头的自定义属性，所以 getAttribute 的兼容性更好
  console.log(box.dataset.index) // 输出 a。也可以使用  dataset["index"]
</script>
```

### 1.5 attributes 属性

Element 类型是唯一使用 attributes 属性的 DOM 节点类型。 attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。 NamedNodeMap 对象包含下列方法：

- getNamedItem(name)，返回 nodeName 属性等于 name 的节点；
- removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；
- setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；
- item(pos)，返回索引位置 pos 处的节点。

attributes 属性中的每个节点的 nodeName 是对应属性的名字， nodeValue 是属性的值。比如，要取得元素 id 属性的值，可以使用以下代码：

```js
let id = element.attributes.getNamedItem('id').nodeValue
// 下面是使用中括号访问属性的简写形式：
let id = element.attributes['id'].nodeValue
```

同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，如下所示：

```js
element.attributes['id'].nodeValue = 'someOtherId'
```

removeNamedItem()方法与元素上的 removeAttribute()方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处， 就是 removeNamedItem()返回表示被删除属性的 Attr 节点：

```js
let oldAttr = element.attributes.removeNamedItem('id')
```

setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：

```js
element.attributes.setNamedItem(newAttr)
```

一般来说，因为使用起来更简便，通常开发者更喜欢使用 getAttribute()、 removeAttribute()和 setAttribute()方法，而不是刚刚介绍的 NamedNodeMap 对象的方法。

### 1.6 修改元素节点的样式

```js
// 直接以行内样式方式修改：属性名一般是驼峰命名法
element.style.backgroundColor = 'red'
element.style.border = '1px solid black'

// 修改类名
element.className = '新的类名'

// 重写元素所有属性
element.style.cssText = 'width: 25px; height: 100px; background-color: green'

// 移除某个属性的样式，采用默认样式
element.style.removeProperty('border')
```

### 1.7 节点比较

isSameNode() 和 isEqualNode():

```js
let div1 = document.createElement('div')
div1.setAttribute('class', 'box')

let div2 = document.createElement('div')
div2.setAttribute('class', 'box')

console.log(div1.isSameNode(div1)) // true
console.log(div1.isSameNode(div2)) // false

console.log(div1.isEqualNode(div2)) // true
```

## 二 节点遍历

### 2.0 深度优先遍历

DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型——NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。

假设有以下 html 结构：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <p>
      <b>Hello</b>
      world!
    </p>
  </body>
</html>
```

### 2.1 NodeIterator

对下面文档中的 body 内的元素进行遍历示例：

```html
<html>
  <body>
    <div id="div">
      <p>
        <b>Hello</b>
        world!
      </p>
      <ul>
        <li>List item 1</li>
        <li>List item 2</li>
        <li>List item 3</li>
      </ul>
    </div>

    <script>
      let div = document.getElementById('div')

      let iterator = document.createNodeIterator(
        div, // 从哪个节点开始遍历
        NodeFilter.SHOW_ELEMENT, // whatToShow 参数：应该访问哪些节点
        null, // filter 参数：是否接收或跳过特定节点
        false // 是否扩展实体引用，在 HTML 中无效！
      )

      let node = iterator.nextNode()
      while (node !== null) {
        console.log(node.tagName) // 输出标签名
        node = iterator.nextNode()
      }
    </script>
  </body>
</html>
```

注意：nextNode() 和 previousNode() 方法共同维护 NodeIterator 对 DOM 结构的内部指针，因此修改 DOM 结构也会体现在遍历中。

第二个参数 whatToShow 是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点，常见定义有：

```txt
NodeFilter.SHOW_ALL，所有节点。
NodeFilter.SHOW_ELEMENT，元素节点。
NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。
NodeFilter.SHOW_TEXT，文本节点。
NodeFilter.SHOW_COMMENT，注释节点。
NodeFilter.SHOW_DOCUMENT，文档节点。
NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。
```

whatToShow 值可以组合使用：

```js
let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
```

创建迭代器示例：

```js
// 创建过滤器方式一
let filter1 = {
  acceptNode(node) {
    return node.tagName.toLowerCase() == 'p'
      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_SKIP
  },
}

// 创建过滤器方式二
let filter2 = function (node) {
  return node.tagName.toLowerCase() == 'p'
    ? NodeFilter.FILTER_ACCEPT
    : NodeFilter.FILTER_SKIP
}

// 创建迭代器
let iterator1 = document.createNodeIterator(
  root,
  NodeFilter.SHOW_ELEMENT,
  filter,
  false
)

// 创建一个简单的遍历所有节点的迭代器
let iterator2 = document.createNodeIterator(
  document,
  NodeFilter.SHOW_ALL,
  null,
  false
)
```

### 2.2 TreeWalker

TreeWalker 是 NodeIterator 的高级版，额外添加了遍历的方向，示例：

```js
let div = document.getElementById('div1')

let filter = function (node) {
  return node.tagName.toLowerCase() == 'li'
    ? NodeFilter.FILTER_ACCEPT
    : NodeFilter.FILTER_SKIP
}

let walker = document.createTreeWalker(
  div,
  NodeFilter.SHOW_ELEMENT,
  filter,
  false
)
let node = iterator.nextNode()
while (node !== null) {
  console.log(node.tagName) // 输出标签名
  node = iterator.nextNode()
}
```

方向示例：

```txt
parentNode()，遍历到当前节点的父节点。
firstChild()，遍历到当前节点的第一个子节点。
lastChild()，遍历到当前节点的最后一个子节点。
nextSibling()，遍历到当前节点的下一个同胞节点。
previousSibling()，遍历到当前节点的上一个同胞节点。
```

节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter.FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。在使用 NodeIterator 时，NodeFilter.FILTER_SKIP 和 NodeFilter.FILTER_REJECT 是一样的。但在使用 TreeWalker 时，NodeFilter.FILTER_SKIP 表示跳过节点，访问子树中的下一个节点，而 NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。例如，如果把前面示例中的过滤器函数改为返回 NodeFilter.FILTER_REJECT（而不是 NodeFilter.FILTER_SKIP），则会导致遍历立即返回，不会访问任何节点。这是因为第一个返回的元素是`<div>`，其中标签名不是"li"，因此过滤函数返回 NodeFilter.FILTER_REJECT，表示要跳过整个子树。因为`<div>`本身就是遍历的根节点，所以遍历会就此结束。

### 2.3 TreeWalker 节点跳跃

TreeWalker 真正的威力是可以在 DOM 结构中四处游走。如果不使用过滤器，单纯使用 TreeWalker 的漫游能力同样可以在 DOM 树中访问`<li>`元素：

```js
let div = document.getElementById('div1')
let walker = document.createTreeWalker(
  div,
  NodeFilter.SHOW_ELEMENT,
  null,
  false
)
walker.firstChild() // 前往<p>
walker.nextSibling() // 前往<ul>
let node = walker.firstChild() // 前往第一个<li>
while (node !== null) {
  console.log(node.tagName)
  node = walker.nextSibling()
}
```

TreeWalker 类型也有一个名为 currentNode 的属性，表示遍历过程中上一次返回的节点（无论使用的是哪个遍历方法）。可以通过修改这个属性来影响接下来遍历的起点：

```js
let node = walker.nextNode()
console.log(node === walker.currentNode) // true
walker.currentNode = document.body // 修改起点
```
