# 08.1-Vue3 与组合式函数

## 一 Vue3 带来的变化

Vue3 核心变化：

- **按需编译**：使得 Vue3 项目的体积比 Vue2 小。
- **Composition API**：即组合式 API，用来更好的组织、复用业务代码，其目的是用来替代 vue2 的生命周期函数
- **性能提升**：性能相比 Vue2 提升较大

Vue3 其他新特性：

- 更先进的组件：Fragment、Teleport、Suspense
- 更好的 TypeScript 支持：Vue3 本身是由 TS 书写，其对 TS 的支持度更高
- 暴露了自定义渲染 API（Custom Renderer API）

## 二 Vue3 性能提升原因

### 2.1 diff 算法优化

Vue2 的虚拟 DOM 是进行全量对比的，Vue3 新增了静态标记（PatchFlag），在与上次的虚拟节点进行比较时，只对比带有 patch flag 的节点。flag 信息中更进一步也存储了具体要比较的具体内容。

### 2.2 组件渲染优化

Vue2 中的元素每次在更新都会重新创建，Vue3 对于不参与更新的元素，只会被创建一次。

Vue2 中节点渲染伪代码：

```js
export function render(){
  return (
    _createNode("p", null, "无变动节点 1")
    _createNode("p", null, "无变动节点 2")
    _createNode("p", null, "更新节点 3")
  )
}
```

静态提升后渲染方式伪代码：

```js
const _hoisted_1 = _createNode('p', null, '无变动节点 1')
const _hoisted_2 = _createNode('p', null, '无变动节点 2')

export function render() {
  return (
    _hoisted_1,
    _hoisted_2,
    _createVNode('p', null, _toDisplayString('有变动节点 3'))
  )
}
```

### 2.3 事件侦听优化

事件绑定函数在默认情况下是动态绑定的，会一直被追踪其变化，源码中使用一个静态标记进行标记。

但是同一个函数，若追踪无变化，组件重新渲染时，静态标记会被取消掉，即不再比较函数的变化。

### 2.4 静态内容缓存

当组件中包含大量静态内容时，这些内容会被当做纯字符串放在 buffer 内，比以前仍然创建虚拟 DOM 渲染快很多。

## 二 组合式 API

### 2.1 shallowReactive()、shallowRef()

`shallowRef()` 只用来实现基本数据类型的响应式，当参数为引用类型则无法实现响应式。应用场景：对象数据在后续使用中不会修改器属性，而是产生新对象来替换。

`shallowReactive()` 只用来保障对象的最外层实现响应式，深层次的对象成员不会被实现响应式。应用场景：应用只有外层属性变化的结构较深的引用类型数据。

浅劫持存在的原因：reactive 内部需要使用递归对嵌套结构的数据进行层层包装为 Proxy 对象，这会造成性能问题，`shallowReactive()`、`shallowRef()`是非递归的。

贴士：shallowRef() 创建的监听数据，同样监听的是 .value 的变化，value 才是第一层。

### 2.2 实现 shallowReative() reactive()

shallowReative() 是最简单的响应式函数，因为其无需递归响应，且参数为对象：

```js
function shallowReactive(target) {
  let flag = target && typeof target === 'object'
  if (!flag) {
    // 基本类型可以直接 return
    return
  }

  return new Proxy(target, reactiveHandler)
}

const reactiveHandler = {
  get(target, prop) {
    return Reflect.get(target, prop)
  },
  set(target, prop, value) {
    return Reflect.set(target, prop, value)
  },
  deleteProperty(target, prop) {
    return Reflect.deleteProperty(target, prop)
  },
}

function reactive(target) {
  if (Array.isArray(target)) {
    target.forEach((item, index) => {
      target[index] = reactive(item)
    })
  } else {
    Object.keys(target).forEach((key) => {
      target[key] = reactive(target[key])
    })
  }

  return new Proxy(target, reactiveHandler)
}
```

## 三 toRef() toRefs() 实现返回值响应式

### 3.1 toRef()

如下场景的响应式是无法实现的，需要借助 toRef()：

```html
<template>
  <h1>{{ age }}</h1>
  <h1>{{ id }}</h1>
  <button @click="updObj">changeObj</button>
</template>

<script>
  import { reactive, toRef } from 'vue'
  export default {
    name: 'HelloWorld',
    setup() {
      let obj = reactive({
        name: 'zs',
        age: 10,
        p: {
          id: 1,
        },
      })

      function updObj() {
        obj.value.age++
        obj.value.p.id++
      }

      // 这里返回的是普通字符串，而不是响应式数据
      //   return {
      //     obj.value.age,
      //     obj.value.p.id,
      //   }

      // 不嫩使用 ref(obj.age),在响应式关系中，如果是用户修改了界面，被响应的数据是 age，而不是 obj,age
      // toRef() 是引用，ref() 是引用
      const age = toRef(obj, 'age')
      const id = toRef(obj.p, 'id')
      return {
        age,
        id,
      }
    },
  }
</script>
```

toRef() 用于创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。一般使用场景为：要将响应式对象中的某个属性单独提供给外部使用时才会使用到 toRef()。

### 3.2 toRefs()

toRefs() 用于引用多个属性：

```js
setup(){

    // ,,,

    return {
        ...toRefs(obj)
    }
}
```

## 四 只读 readonly()、shallowReadonly()

readonly()、shallowReadonly() 函数均接收一个响应式数据，返回一个新的数据：

```js
let p = reactive({ age: 10, name: 'zs' })

p = readonly(p)
```

经过 readonly() 加工的响应式数据是只读的，shallowReadonly() 只会加工对象的最外层。

## 五 toRaw()、markRow() 转变响应式数据为普通对象

toRow()：将 reactive() 生成的响应式对象转化为普通对象。一般用于操作数据时不想造成页面更新的场景。

markRow()：标记一个对象，使其永远不会成为响应式对象。一般用于一些复杂的第三方库、渲染不可变数据源的大列表。

## 六 customRef() 显式控制 ref

`customRef()` 用于创建一个自定义 ref，并对其依赖项进行跟踪，以及对其更新触发进行显式控制。

实现防抖效果：

```html
<template>
  <input type="text" v-model="keyword" />
  <h3>{{keyword}}</h3>
</template>

<script>
  import { ref, customRef } from 'vue'
  export default {
    name: 'Demo',
    setyp() {
      // let keyword = ref('hello')
      function myRef(val, delay = 300) {
        let timer
        return customRef((track, trigger) => {
          return {
            get() {
              track()
              return val
            },
            set(newVal) {
              clearTimeout(timer)
              timer = setTimeout(() => {
                val = newVal
                trigger()
              }, delay)
            },
          }
        })
      }

      // 自定义 myRef
      let keyword = myRef('hello')
      return { keyword }
    },
  }
</script>
```

## 七 响应式数据判断

- isRef()：检查值是否由 ref() 创建
- isReactive()：检查对象是否由 reactive() 创建
- isReadonly()：检查对象是否由 readonly() 创建
- isProxy()：检查对象是否由 readonly()/readonly() 创建

## 八 自定义 hook 函数

vue3 的组合 api 可以封装为复杂的可复用的功能函数，类似 vue2 中的 mixin，但是更加清晰：

```js
// 新建一个 hook 文件夹，内部创建多个 hookapi 文件，如下示例
import { ref, onMounted, onUnmounted } from 'vue'

export default function useShowMousePosition() {
  const x = ref(-1)
  const y = ref(-1)

  const run = (e: MouseEvent) => {
    x.value = e.pageX
    y.value = e.pageY
  }

  onMounted(() => {
    document.addEventListener('click', updPos)
  })

  onUnMounted(() => {
    document.addEventListener('click', updPos)
  })
}

// 业务代码中使用
export default {
  name: 'HelloWorld',
  setup() {
    const { x, y } = useMousePosition()
  },
}
```
